# Requirements

The C standard, the nature of the 6502, and the nature of each target platform
will impose a number of requirements for the design of a compiler. These requirements are gathered here, organized by topic.

## Target Memory

The addresses that are safe for a program to use may differ from system to
system, even within the same product type. There are two ways to deal with
this: restrict the program to only operate correctly on a particular system, or
target a conservative version of the system, and use autodetection to take
advantage of bigger systems. The compiler should support both: automatic
allocation of and use of more RAM and conservative allocation that is
guaranteed to work on a set of systems, no matter how they are configured.

### Atari 800

The program is booted by the OS; thus the compiler cannot load at boot any
resources that are used by the OS. The program may be able to free up
additional resources after boot. Such resources can be made accessible as
automatic program space, including zero page registers, additional memory
locations, and stack space. To allow this, the compiler should optionally run a
user-provided initialization routine after boot. This routine would run under
the boot configuration of the system and would place the system into a new
configuration. A description of the new configuration would be provided
alongside the routine; after the routine is run, the compiler assumes the
system is in the state described.

## Address Sensitivity

A number of 6502 constructs depend on the location in which code or data is
stored in the address space of the processor.

All zero page addressing modes can only deal with entries in the first 256
memory locations. In many ways, these locations are special, must like
processor registers are special. However, they do also have two-byte numeric
addresses and can be accessed just like other memory locations.

All branch instructions target code memory locations based on an offset from
the branch itself. The greatest distance that can be branched is 127 bytes
forward and 128 bytes backward from the instruction following the branch.
Further branches need to be generated by a branch to an absolute JMP
instruction. The compiler will need to do this even if the assembler can do
this automatically, since a branch followed by a jump is twice as expensive as
a branch, and the distinction should be incorporated into the compilers' cost
model.

If an indirect jump is issued where *xx*FF, for any *xx*, the address to jump
to will be read from *xx*FF and *xx*00, rather than from the logically
correct location, *xx*FF and *xx*FF+1. The processor essentially forgets to
add 1 to the high-order byte. The compiler should prevent this from
occurring; this allows easy compatibility with the CMOS version of the chip
at almost no cost.

Indexed zero page accesses are also vulnerable to this wrap-around. If X=1
and `LDA $FF,X` is issued, the A register will be loaded with the value from
address 0, not from 0x100. Zero page indexing should thus be considered to use
modular arithmetic. The compiler should instead use the absolute indexed
addressing modes whenever there is a risk of wrap-around.

Wrap-around also occurs for the indexed modes; for example, `LDA ($FF),Y`
with Y=0 loads A with the value at the address stored at the addresses 0xFF
and 0. The compiler should avoid placing any addresses that will be
indirected through on the 0xFF-0x100 boundary. Any tables using the ($*xx*,X)
addressing mode must be ensured to fit entirely on the zero page. This
wrap-around behavior may be used to subtract X from the address instead of
adding it via 2's complement behavior.

A number of instructions are more expensive when page boundaries are crossed;
this should be incorporated into the compiler's cost model.

## Spurious Reads and Writes

Indexed addressing modes that cross page boundaries (start address + index is
not at the same 256-byte page as the start address), the processor first issues
an erroneous read from the old page, exactly 256 bytes prior to the correct
address. Then the read/write occurs at the correct location. CMOS versions do
not have this behavior. The compiler must ensure that no addresses with I/O
behavior triggered on a read are accessed in such a way.

Read-modify-write instructions like INC first write the unmodified data, then
the modified data. CMOS versions instead issue two reads, but only one write.
Even though it is permissible by the standard, the compiler should not use
these instructions for volatile types, since the behavior is quite surprising
and is not necessary.

## Data

### ROM

Objects in static storage need to be initialized *before* program startup
(C89 2.1.2). For ROM output, this means that mutable static objects need to be
copied to RAM locations. These would become the canonical locations for the
objects.

Non-`volatile` `const` objects with statically-known values may be placed in
ROM, and if their address is never used, they need not be allocated at all.
This is actually true of any objects that has a statically-known value that can
be proven never to be modified (`const` just ensures this).

`volatile const` objects should not be placed in ROM and must be allocated,
since the intent is that ASM code or hardware unknown to the C compiler should
be able to modify the value.

### Constant Expressions

Address constant expressions may be used in static initializers, and they refer
to part or all of other static objects or functions. These may even be
self-referential; for instance, a static struct with a recursive pointer can
refer to its own address.

Constant expression evaluation is free to use the host arithmetic, so long as
it is more precise than the target (not hard.)

### Automatic Storage

Automatic objects that can be proven never to be present in two simultaneously
active invocations can be treated much like static objects.  If the objects
were initialized, the initialization still needs to happen each time, unlike
other statics, which are initialized before program startup.  If the value of
such an object is used, it was set in some currently-active procedure; such
values cannot by their nature persist between calls.

Values of pointers to auto objects in terminated blocks are indeterminate.
This means that objects in blocks that cannot be simultaneously active can
safely share the same pointer value.

It's simplest to only bump the stack pointer once at the beginning of a
function. Otherwise, any goto statements that enter a block need to allocate
all the space required for that block.

## Volatile

Reads from volatile objects need to be treated differently than regular reads,
so that information needs to be extacted from LCC (C89 2.1.2.3).

### Characters

Escape characters should not output a printable character.

Alert must not change the cursor position.

Carriage return should move the cursor to the initial position of the current
line.

Sign extending chars is expensive on the 6502, and at least one major POSIX
platform (ARM) does not sign extend chars. Thus, the implementation, like ARM,
defines `CHAR_MIN` to be `0` and `CHAR_MAX` to be the same as `UCHAR_MAX`.

The preprocessor needs to be modified to understand the target character set,
since character literals can be used in constant expressions for conditional
compilation. This means that the mechanism for controlling execution character
sets needs to be visible to the preprocessor.

LCC's preprocessor currently just uses the source character set, but it's easy
to change in `cpp/eval.c` (line 502).  A warning about long character constants
in `cpp/eval.c` should also be removed.

The LCC compiler should be set so that wide characters are the same size as
regular characters, since nobody is going to care about wide characters on this
platform.

## Floating Point

The impelementation should probably use Berkely SoftFloat v2, since:
* It's very easy to port to new platforms, even those with odd int sizes.
* It's IEEE 754 compliant, and supports binary32 and binary64.
* It has a sufficiently permissive license.
  * TODO: A notice must be included somewhere in the standard library source
    that the standard library is a deriviative work of the Berkeley SoftFloat
    library.
* The later versions (v3) require the target to support 64-bit integers.

### Structs and Unions

LCC performs struct initialization much like character array initialization.
Space for the initializer is statically allocated, and an assignment is issued
at the beginning of the block from the static location to the variable. This
works because aggregate types can only be initialized with compile-time
constants. LCC does not combine identical initializers; instead, it creates one
initializer per struct literal instance in the source text.

Identical initializers can be easily detected in the backend. This should be
done, since it will save precious space.

#### Bit-Fields

See the [LCC bit-field experiments](lcc/experiments/bitfield/README.md) for
LCC's behavior regarding bit-field.

In particular, LCC generates bit operations necessary to implement bit-field
over arbitrary bytes. The compiler always accesses bit-fields as
2-byte ints, even if the entire struct is only one byte long. When a
bit-field is modified, all data outside the bit-field is read and written back
unmodified. This means that writing to a bit-field can modify data outside of
the struct, even if that data is marked volatile.

Volatile just means that the compiler must access the value whenever the
program says to, not that the compiler must ensure that it never touches such
an object except when the program says so. This has been a point of contention
in the C community. The backend should always be able to lower such accesses to
1 byte. This is both faster and less surprising. The confusing behavior can
still occur if a volatile bit-field is next to a non-volatile one in the same
struct.

## Code

### Signals/Interrupts

Automatic variables need to retain their values across signal handling
suspensions (C89 2.1.2.3). This implies either keeping them in no-clobber registers
or saving them on a stack.

No signals need be provided, but to allow implementing signals, intterupt
handlers must be writable in pure C. Any function can be interrupted at any
time by an interrupt, which can call any C function.

Interrupt handlers must not overrite any locations (memory or register) used by
previous invocations or by any active functions.

Interrupt handlers often need to be extremely timely, so the number of
locations saved and restored by the handler must be tightly bounded.

The BRK instruction can be swallowed in NMOS chips if a hardware interrupt
occurs while one is being fetched. This was corrected in the CMOS
implementation. To avoid this complexity, and due to insufficient utility, the
BRK instruction should not be used by the compiler.

### Code Size

For many practical programs, it may be difficult to fit the program and its
data into available RAM. A program may reserve space for data using static
variables.

Since the target machines do not have Memory Management Units, much of the
address space is unavailable for use by the program. The compiler should pack
the program and its data into the available RAM as tightly as possible. Some
programs may still be too big to fit; these may be rejected.

No optimizations (inlining, etc) may be performed unless it can be guaranteed
that it will not cause a program to no longer fit into RAM. Note that many
optimizations tend to reduce both code size and execution time. When
optimization is enabled, the compiler should always aim for the most efficient
program that can be made to fit.

### Functions

Each function needs to support at least 31 arguments (C89 2.2.4.1). That's at least
31 bytes of storage.

Prototyped functions with no "narrow" types (smaller than int) and no variable
argument list must be callable in translation units without the prototype.

Return statements with no value are legal in functions with non-void return
types, so long as the return value is never used by the caller.

#### System Calls

The Atari 800 provides a number of OS routines with their own calling
conventions. The compiler should allow C code to call these somehow.

TODO: Determine the mechanism once all examples have been collected.

Calling CIO routines involves first setting up a set of IOCB memory locations
to the proper value, then setting the X register IOCB number times 16 in the
X register, and then possibly setting the A register a data byte. A JSR to
the CIO entry point is then issued. Afterward, the X register is unchanged,
but the Y register is set to an error status. The condition flags Zero and
Negative of the processor reflect the value in the Y register. The IOCB
memory locations are also updated to reflect the number of bytes written,
status, etc.

Calling resident I/O handlers without going through CIO requires jumping to
an address given by an entry in a table of addresses provided by the OS.
However, each address is one less than it should be. This is to facilitate
pushing the address on the stack, then using RTS to jump to the address.
(This is smaller but slower than loading the address into the zero page and
using an indirect JMP.) RTS adds one to the address it takes off the stack to
move the PC to the instruction after the corresponding JSR. The compiler
needs to support using RTS to execute this kind of indirect jump.

#### Variable-Sized Argument Lists

`va_start` and `va_arg` are macros, not functions.

Variable argument functions can only be called in the presence of a prototype,
so the compiler is always aware that such calls involve variable arguments.
Thus, a totally different calling convention can be used.

`va_start` includes the first non-variable argument as a parameter, but its use
is totally optional.

For efficiency, like with regular functions, the arguments should probably be passed in registers.

va_start can copy any registers used by the function to a register save area
in the `va_list`. The number of registers used can be passed as well, to allow
only saving passed values. Values that are not used need not be saved.

The argument list can be scanned more than once, so the arguments need to be
preserved, even after a traversal completes.

Each of these can be implemented in terms of magic compiler builtins.
__builtin_va_arg returns a void* pointer that is cast to the corresponding type
and indirected through in a macro. This pointer is not real; it will be
completely removed by the code generator. The compiler will emit a warning if a
void pointer is cast to a function type; this must be suppressed in this
case, since the pointers don't actually "exist". This complexity saves creating
a special compiler form, which is even more complex.

#### switch Statements

At least 257 case labels need to be supported (C89 2.2.4.1). This precludes
creating a sort of byte-indexed perfect-hashed jump table, since there would be
too many entries in the worst case. This is to allow branching on any character
as well as EOF.

#### setjmp/longjmp

This implementation needs to define <setjmp.h>, since it may need significant
compiler support to implement.

Unlike other library functions, setjmp can be a macro without a corresponding
external identifier. Trying to access it as a function (taking its address,
etc.) is undefined behavior. Additionally, the following forms are the only
defined uses of setjmp:
* ```if/while/do-while (setjmp(<...>))```
* ```if/while/do-while (!setjmp(<...>))```
* ```if/while/do-while (setjmp(<...>) ==/!= <int const>)```
* ```setjmp(<...>);```

Life goes on after setjmp is called; various changes can be made to automatic
variables in the setjmp-containing function. It's desirable that each variable
has the exact value it had when longjmp was called, but this is difficult to
achieve. If any of those automatic variables is in a register, then that
register may have been saved and reused by some intervening function. But
longjmp can't easily restore the saved value for that register, since it may be
in an even deeper function.

To solve the this dilemma, most setjmp/longjmp implementations just save the
values when *setjmp* was called, and restore those. This is correct if and only
if the values have not changed since setjmp was called. The standard
specifically allows this, so long as the automatic variables are not marked
`volatile`. Volatile automatic objects and static objects must have their
values at the time of the longjmp, even if they have changed since the setjmp;
accordingly, they cannot easily be stored in a register in any function that
can call setjmp.

It's OK for setjmp and longjmp to be fairly slow, but they can't be so slow
that they save and restore every single usable zero page address each time they
are called. This complicates naively using zero page addresses as registers.

Longjmp needs to pop all return addresses (and anything else) off of the stack
until the stack is restored to its state at the time of setjmp. Nothing need
actually be changed, but the stack register must change. This is true for any
soft stacks used as well; these soft stack pointers need to be reset.

Longjmp provides an alternative way that an invocation of a function can be
terminated. All invocations on the logical stack between the caller of setjmp
and the call of longjmp are terminated. If an interrupt handler is terminated
in this way, the computation that was occurring no longer matters; it can be
considered abandoned. Thus, the flags that were pushed onto the stack by the
interrupt handler no longer matter. The processor should remain in the state it was in when the longjmp was issued; including the interrupt enable flag.

## Libraries

Prototypes in library headers may only use identifiers in the reserved
namespace (`__x` or `_X`). Otherwise, the user could place a #define macro
before the header as follows:

```C
#define status []
void exit(int status);
```

This becomes:

```C
void exit(int []);
```

