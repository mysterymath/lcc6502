## Runtime 

Let's consider SSA form, since it simplifies the nature of objects and
values. In SSA form, values have exactly one definition, but possibly many
uses. On the other hand, objects are represented by pointer values. Values
may be defined by loading from an object pointer, and a value may be stored
through an object poiner. Some C objects become a set of related values,
while others become SSA objects.

Using this, all objects must be in memory. If neither a store nor a volatile
access can occur, the value can be placed in ROM. Otherwise, it must be in
RAM. RAM objects can be in the zero page or outside.

Some objects have lifetimes that are unbounded; these are static objects.
Other objects have bounded lifetime. If it can be proven that two objects'
lifetimes cannot intersect, those objects can safely share the same memory
address.

Values also need to be allocated to locations. For simplicity, each value
should receive a designated storage location, where it is expected to reside
for most of its life. If this conflicts with another resource, the value may
temporarily be saved to another location and restored before its next use. If
the value must reside in a current kind of location, the value in an location
may be saved, the value temporarily loaded into the location, the use occur,
and the original instance restored.

Values could be allocated to machine registers, zero page memory locations,
or regular memory locations. Values also have lifetimes, the range between
the definition and the last use. Two values (or a value and an object) may
only be assigned to overlapping locations if it can be proven that they do
not have overlapping lifetimes.

All values and objects alive when setjmp is called should, on the face of it,
have their lifetimes extended to the time of the last possible corresponding
longjmp call. As a concession, C89 allows automatic nonvolatile variables
that were changed after setjmp to have indeterminate value upon longjmp. This
means that setjmp can take a snapshot of all visible values, and longjmp can
restore those values, ignoring any possible changes. This means that only
volatile objects need have their lifetime extended, which eases allocation in
the functions below the setjmp-bearing function. As a tradeoff, it creates
save-restore overhead for the setjmp-longjmp pair. This overhead must be kept
tightly bounded.

Assembly language routines outside the C program are, for the most part,
invisible to the compiler. As such, an assembly language routine called from
C could modify any register or memory location, except those specifically
reserved for use by the compiler. A call to C from assembly language could
overwrite values used by the assembly code as well. To avoid these kinds of
issues, there needs to be a convention for calling C from ASM and ASM from C.

As mentioned before, some locations must definitely be reserved for compiler
use only. Otherwise, static objects could not be counted on to have reliable
values, and code in RAM could not be counted on not to change. However,
it's unreasonable to expect all resources used by the compiler to be exclusive
to it, since both assembly language routines and the C compiler have a need
for all of the processor's registers and flags, and at least some zero page
memory locations.

Which locations can be reserved for compiler purposes will depend on the
execution environment. Accordingly, this must be manually specified by
the developer in a compiler config file.

There must also be some forbidden locations that the compiler can never use.
To see why, consider ASM code occurring in interrupt handlers. These can
occur at any point within a C function, so there is no safe place to put save
and restore code around the use of such resources. An interrupt could always
occur after the save and see the overwritten value. Accordingly, a list of
forbidden locations must also be manually specified by the developer in a
compiler config file.

For locations that are neither reserved nor forbidden, the C code and ASM
code must coordinate the use. Some of these should be designated caller-save,
and the callee is free to modify them at will. Others should be designated
callee-save, and the callee must ensure that upon return they have the same
values as the start of the call. A convention should also be established for
parameter passing and return value passing.

If a C function is called inside an interrupt across a FFI boundary, and all
possible arguments are passed to it, then every free location used to produce those
arguments must necessarily be saved and restored. This means that keeping
the save/restore cost per-interrupt bounded requires keeping the number of
arguments passed in free locations bounded.

Accordingly:

A and X should be used to pass arguments/return values. After that, just use stack.

TODO: Linker script specification.

## ASM file

All code and initializers must be stored into a binary that can somehow be
loaded into the target machine. The specifics of this will vary greatly by
target and execution environment, so the compiler should aim to be generic.

Accordingly, the compiler produces raw ASM files containing the code and
object initializers. Each function and object will have a runtime address
associated with it. It is the responsibility of the author of a wrapping ASM
file to ensure that all code and initialized objects are present at their
runtime addresses before each reference. This ASM routine will also call
the entry C function, called `main` by convention.